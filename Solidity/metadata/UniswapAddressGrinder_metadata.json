"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"startingSalt\",\"type\":\"bytes32\"}],\"name\":\"findSaltForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isQuaiCompatibleAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"predictDeploymentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract has the grinding logic built-in rather than relying on external scripts\",\"events\":{\"ContractDeployed(address,bytes32)\":{\"params\":{\"deployedAddress\":\"The address of the deployed contract\",\"salt\":\"The ground salt used for the deployment\"}}},\"kind\":\"dev\",\"methods\":{\"computeAddress(bytes32,bytes32)\":{\"params\":{\"initCodeHash\":\"The hash of the init code for the contract to be deployed\",\"salt\":\"The salt value to use in the CREATE2 operation\"},\"returns\":{\"_0\":\"The address the contract will be deployed to\"}},\"deployContract(bytes,bytes,bytes32)\":{\"params\":{\"bytecode\":\"The bytecode of the contract to deploy\",\"constructorArgs\":\"The ABI-encoded constructor arguments for the contract\",\"salt\":\"The initial salt value for the CREATE2 operation\"},\"returns\":{\"deployedAddress\":\"The address where the contract was deployed\"}},\"findSaltForAddress(bytes32,bytes32)\":{\"params\":{\"initCodeHash\":\"The hash of the init code for the contract to deploy\",\"startingSalt\":\"The initial salt value to start searching from\"},\"returns\":{\"_0\":\"A salt value that will result in a Quai-compatible address\"}},\"isQuaiCompatibleAddress(address)\":{\"params\":{\"addr\":\"The address to check\"},\"returns\":{\"_0\":\"True if the address is compatible (first byte 0x00 and second byte <= 127)\"}},\"predictDeploymentAddress(bytes,bytes,bytes32)\":{\"params\":{\"bytecode\":\"The bytecode of the contract to deploy\",\"constructorArgs\":\"The ABI-encoded constructor arguments for the contract\",\"salt\":\"The initial salt value for the CREATE2 operation\"},\"returns\":{\"_0\":\"predictedAddress The predicted address where the contract will be deployed\"}}},\"title\":\"UniswapAddressGrinder\",\"version\":1},\"userdoc\":{\"events\":{\"ContractDeployed(address,bytes32)\":{\"notice\":\"Emitted when a contract is deployed\"}},\"kind\":\"user\",\"methods\":{\"computeAddress(bytes32,bytes32)\":{\"notice\":\"Computes the address a contract will be deployed to using CREATE2\"},\"deployContract(bytes,bytes,bytes32)\":{\"notice\":\"Deploys a contract with an address compatible with Quai Network's sharding requirements\"},\"findSaltForAddress(bytes32,bytes32)\":{\"notice\":\"Finds a salt that will generate a Quai-compatible address\"},\"isQuaiCompatibleAddress(address)\":{\"notice\":\"Checks if an address is compatible with Quai Network's sharding requirements\"},\"predictDeploymentAddress(bytes,bytes,bytes32)\":{\"notice\":\"Predicts the address where a contract will be deployed\"}},\"notice\":\"Contract for deploying Uniswap contracts with addresses compatible with Quai Network's sharding requirements\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/UniswapAddressGrinder.sol\":\"UniswapAddressGrinder\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/UniswapAddressGrinder.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.7.6;\\n\\n/// @title UniswapAddressGrinder\\n/// @notice Contract for deploying Uniswap contracts with addresses compatible with Quai Network's sharding requirements\\n/// @dev This contract has the grinding logic built-in rather than relying on external scripts\\ncontract UniswapAddressGrinder {\\n  /// @notice Emitted when a contract is deployed\\n  /// @param deployedAddress The address of the deployed contract\\n  /// @param salt The ground salt used for the deployment\\n  event ContractDeployed(address indexed deployedAddress, bytes32 salt);\\n\\n  /// @notice Finds a salt that will generate a Quai-compatible address\\n  /// @param initCodeHash The hash of the init code for the contract to deploy\\n  /// @param startingSalt The initial salt value to start searching from\\n  /// @return A salt value that will result in a Quai-compatible address\\n  function findSaltForAddress(bytes32 initCodeHash, bytes32 startingSalt) public view returns (bytes32) {\\n    bytes32 salt = startingSalt;\\n\\n    for (uint256 i = 0; i < 10000000; i++) {\\n      address computedAddress = computeAddress(salt, initCodeHash);\\n\\n      // Check if the first byte is 0x00 and the second byte is <= 127\\n      if (uint8(uint160(computedAddress) >> 152) == 0x00 && uint8(uint160(computedAddress) >> 144) <= 127) {\\n        return salt;\\n      }\\n      // Increment the salt by adding 1 (will wrap around if it exceeds 256-bit size)\\n      salt = bytes32(uint256(salt) + 1);\\n    }\\n\\n    // Return 0 if no salt is found (although it will theoretically run until it finds one)\\n    return bytes32(0);\\n  }\\n\\n  /// @notice Computes the address a contract will be deployed to using CREATE2\\n  /// @param salt The salt value to use in the CREATE2 operation\\n  /// @param initCodeHash The hash of the init code for the contract to be deployed\\n  /// @return The address the contract will be deployed to\\n  function computeAddress(bytes32 salt, bytes32 initCodeHash) public view returns (address) {\\n    // Calculate the address using the same formula as CREATE2\\n    bytes32 hash = keccak256(\\n      abi.encodePacked(\\n        bytes1(0xff), // Fixed prefix used in CREATE2\\n        address(this),\\n        salt,\\n        initCodeHash\\n      )\\n    );\\n\\n    // Convert the last 20 bytes of the hash to an address\\n    return address(uint160(uint256(hash)));\\n  }\\n\\n  /// @notice Checks if an address is compatible with Quai Network's sharding requirements\\n  /// @param addr The address to check\\n  /// @return True if the address is compatible (first byte 0x00 and second byte <= 127)\\n  function isQuaiCompatibleAddress(address addr) public pure returns (bool) {\\n    return uint8(uint160(addr) >> 152) == 0x00 && uint8(uint160(addr) >> 144) <= 127;\\n  }\\n\\n  /// @notice Deploys a contract with an address compatible with Quai Network's sharding requirements\\n  /// @param bytecode The bytecode of the contract to deploy\\n  /// @param constructorArgs The ABI-encoded constructor arguments for the contract\\n  /// @param salt The initial salt value for the CREATE2 operation\\n  /// @return deployedAddress The address where the contract was deployed\\n  function deployContract(bytes memory bytecode, bytes memory constructorArgs, bytes32 salt) external returns (address deployedAddress) {\\n    // Combine bytecode and constructor arguments\\n    bytes memory initCode = abi.encodePacked(bytecode, constructorArgs);\\n\\n    // Hash the init code for CREATE2\\n    bytes32 initCodeHash = keccak256(initCode);\\n\\n    // Find a salt that will generate a Quai-compatible address\\n    bytes32 groundSalt = findSaltForAddress(initCodeHash, salt);\\n\\n    // Deploy contract using CREATE2 with the ground salt\\n    assembly {\\n      deployedAddress := create2(0, add(initCode, 0x20), mload(initCode), groundSalt)\\n    }\\n\\n    // Check if deployment was successful\\n    require(deployedAddress != address(0), 'UniswapAddressGrinder: Contract deployment failed');\\n\\n    // Verify the deployed address is Quai-compatible\\n    require(isQuaiCompatibleAddress(deployedAddress), 'UniswapAddressGrinder: Deployed address not compatible with Quai Network');\\n\\n    // Emit the ContractDeployed event\\n    emit ContractDeployed(deployedAddress, groundSalt);\\n\\n    return deployedAddress;\\n  }\\n\\n  /// @notice Predicts the address where a contract will be deployed\\n  /// @param bytecode The bytecode of the contract to deploy\\n  /// @param constructorArgs The ABI-encoded constructor arguments for the contract\\n  /// @param salt The initial salt value for the CREATE2 operation\\n  /// @return predictedAddress The predicted address where the contract will be deployed\\n  function predictDeploymentAddress(bytes memory bytecode, bytes memory constructorArgs, bytes32 salt) external view returns (address) {\\n    // Combine bytecode and constructor arguments\\n    bytes memory initCode = abi.encodePacked(bytecode, constructorArgs);\\n\\n    // Hash the init code for CREATE2\\n    bytes32 initCodeHash = keccak256(initCode);\\n\\n    // Find a salt that will generate a Quai-compatible address\\n    bytes32 groundSalt = findSaltForAddress(initCodeHash, salt);\\n\\n    // Predict the deployment address\\n    return computeAddress(groundSalt, initCodeHash);\\n  }\\n}\\n\",\"keccak256\":\"0x200c66765556e6278ef2e0307369fe6f9a98bb63ef125e7391d90199e567afea\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}"